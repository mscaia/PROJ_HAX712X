{
  "hash": "ac69933217a7f5d7f89b5daf1115339a",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Documentation\n---\n\n\n\n\n# 1. Introduction\n\nThis project explores and visualizes bike traffic in Montpellier by analyzing data from multiple sources and generating interactive maps. The goal is to provide valuable insights into the city's bike traffic patterns, which will support urban mobility planning and decision-making.\n\n# 2. Project Objectives\n\n- **Traffic Analysis**: Analyze bike traffic data to identify trends, peak times, and popular routes.\n- **Interactive Visualization**: Create dynamic maps that visualize traffic flows across Montpellier.\n- **Web Integration**: Develop a user-friendly website to showcase data insights and traffic maps.\n\n# 3. Data Sources\n\nOur analysis relies on three primary datasets:\n\n- **VéloMagg Bike-Sharing Data**: Information on bike-sharing usage within the Montpellier Méditerranée Métropole area.\n- **Traffic Counts Data**: Sensor data recording bike and pedestrian counts at various locations throughout the city.\n- **OpenStreetMap (OSM) Data**: Geographic data used to accurately map streets, bike lanes, and important locations.\n\n# 4. Project Workflow\n\n## 4.1 Data Cleaning and Preprocessing\n\n### Tasks:\n- **Data Integrity**: Clean the data by removing anomalies, handling missing values, and ensuring consistent formatting.\n- **Date and Address Formatting**: Convert date fields for temporal analysis and standardize address formatting to enable efficient location-based processing.\n\n## 4.2 Traffic Visualization and Mapping\n\n### Tasks:\n- **Map Generation**: Use the Folium library to generate an interactive map of Montpellier, displaying bike stations, routes, and traffic density.\n- **Route Calculation**: Utilize OSMnx to calculate the routes between bike stations, highlighting the most popular paths and enabling traffic analysis over time.\n\n## 4.3 Website Development\n\nThe final deliverable will be an interactive website, presenting all the data visualizations and analytical insights. The website will be developed using Quarto for easy integration of analysis and visualizations into an accessible, interactive interface.\n\n# 5. Technical Documentation\n\n# 5.1 Bibliothèques utilisées\n\nDans le cadre de ce projet, plusieurs bibliothèques ont été utilisées pour répondre aux différents besoins techniques et analytiques. Voici une présentation des bibliothèques principales et leur rôle.\n\n<details> <summary>`csv`</summary>\nLa bibliothèque `csv` permet de lire et d’écrire des fichiers CSV, un format commun pour manipuler des données tabulaires.\nNous avons utilisé `csv` pour extraire et traiter les données brutes contenues dans des fichiers au format CSV. Cela est particulièrement utile pour manipuler des ensembles de données simples où une lecture ligne par ligne est nécessaire.\n</details>\n\n<details> <summary>`matplotlib.pyplot`</summary>\n`matplotlib.pyplot` est utilisée pour produire des graphiques statiques et analyser visuellement les données.\nCette bibliothèque nous permet de visualiser les tendances, les répartitions et les relations dans les données à l’aide de graphiques tels que les histogrammes, les courbes ou les nuages de points.\n</details>\n\n<details> <summary>`numpy`</summary>\n`numpy` est une bibliothèque puissante pour effectuer des calculs numériques avancés, notamment des opérations matricielles.\nLes opérations matricielles et les calculs numériques complexes nécessaires à l’analyse des données sont simplifiés grâce à `numpy`, qui garantit également des performances élevées.\n</details>\n\n<details> <summary>`os`</summary>\n`os` fournit des fonctions pour interagir avec le système d’exploitation, notamment pour gérer les fichiers et les répertoires.\nNous avons utilisé `os` pour gérer les chemins des fichiers, vérifier l’existence des répertoires, et manipuler les ressources locales du système.\n</details>\n\n<details> <summary>`pooch`</summary>\n`pooch` facilite le téléchargement et la mise en cache des fichiers nécessaires à l’exécution du projet.\nCette bibliothèque permet de garantir un accès fiable aux données externes en les téléchargeant automatiquement et en les stockant localement pour une réutilisation future.\n</details>\n\n<details> <summary>`pandas`</summary>\n`pandas` est essentielle pour manipuler et analyser des données tabulaires de manière efficace.\n`pandas` est utilisée pour nettoyer, transformer et analyser des ensembles de données complexes, offrant des fonctionnalités avancées comme le traitement des séries temporelles et des jointures de tables.\n</details>\n\n<details> <summary>`json`</summary>\n`json` est utilisée pour manipuler des données au format JSON, un standard de stockage et d’échange d’informations structurées.\nNous utilisons `json` pour lire et écrire des données structurées, notamment pour gérer les configurations et les résultats intermédiaires dans des fichiers légers.\n</details>\n\n<details> <summary>`re`</summary>\nLa bibliothèque `re` permet de travailler avec des expressions régulières pour manipuler des chaînes de caractères.\nGrâce à `re`, nous avons pu extraire des informations spécifiques des chaînes de caractères et nettoyer les données textuelles de manière efficace.\n</details>\n\n<details> <summary>`unicodedata`</summary>\n`unicodedata` est utilisée pour normaliser les chaînes de caractères Unicode. \nCette bibliothèque est essentielle pour traiter les caractères spéciaux et garantir la cohérence des chaînes de caractères provenant de différentes sources.\n</details>\n\n<details> <summary>`folium`</summary>\n`folium` est une bibliothèque dédiée à la création de cartes interactives. \nNous avons utilisé `folium` pour visualiser les trajets et itinéraires des vélos sur des cartes interactives, permettant une meilleure compréhension géographique des données.\n</details>\n\n<details> <summary>`osmnx`</summary>\n`osmnx` est utilisée pour le géocodage et l’analyse des réseaux géographiques.\nCette bibliothèque permet de calculer des itinéraires, de géocoder les points d’intérêt et d’extraire des données à partir d’OpenStreetMap pour analyser les réseaux routiers.\n</details>\n\n<details> <summary>`functools.lru_cache`</summary>\n`functools.lru_cache` est une fonctionnalité de Python pour optimiser les performances.\nEn mettant en cache les résultats des fonctions fréquemment appelées, `functools.lru_cache` améliore les performances et réduit le temps de calcul pour des opérations répétées.\n</details>\n\n# 5.2 Function Documentation\n\n<details> \n  <summary>`colonne(i, w_file)`</summary>\n  Cette fonction permet d'extraire une colonne spécifique d'un fichier CSV. Elle prend en entrée un indice `i`, représentant la colonne à extraire, ainsi que le chemin du fichier `w_file`. La fonction ouvre le fichier, parcourt chaque ligne et récupère l'élément situé à la position `i` dans chaque ligne. Le résultat est une liste contenant toutes les valeurs de la colonne souhaitée.\n\n  **Paramètres** : \n  - `i` (int) : L'indice de la colonne à extraire.\n  - `w_file` (str) : Le chemin d'accès au fichier CSV.\n\n  **Retourne** : \n  - `L` (list) : Une liste contenant les valeurs de la colonne spécifiée.\n\n\n  ::: {#b4a8a93c .cell execution_count=1}\n  ``` {.python .cell-code}\n  def colonne(i, w_file):\n    L=[]\n    with open(w_file) as f:\n        for line in f:\n            x=line.split(\",\")\n            L.append(x[i])\n    return L \n  ```\n  :::\n  \n  \n</details>\n\n<details> \n  <summary>`arg(k, i, j, w_file)`</summary>\n  Cette fonction retourne toutes les valeurs dans la colonne `j` lorsque l'argument dans la colonne `i` est égal à `k`. Elle est utile pour filtrer un ensemble de données en fonction d'une condition donnée dans une colonne spécifique, puis extraire les valeurs correspondantes dans une autre colonne.\n\n  **Paramètres** : \n  - `k` (str) : La valeur de la colonne `i` que l'on souhaite rechercher.\n  - `i` (int) : L'indice de la colonne à vérifier.\n  - `j` (int) : L'indice de la colonne dont les valeurs seront extraites.\n  - `w_file` (str) : Le chemin d'accès au fichier CSV.\n\n  **Retourne** : \n  - `L` (list) : Une liste des valeurs de la colonne `j` correspondant à la condition `x[i] == k`.\n</details>\n\n<details> \n  <summary>`pd_to_datetime(df, colonne_date)`</summary>\n  Cette fonction transforme une colonne de dates dans un DataFrame en un format exploitable. Elle supprime les valeurs manquantes, convertit la colonne de dates en format `datetime` et crée une nouvelle colonne `Date` contenant uniquement la date, en supprimant la colonne initiale des dates.\n\n  **Paramètres** : \n  - `df` (DataFrame) : Le DataFrame contenant la colonne de dates.\n  - `colonne_date` (str) : Le nom de la colonne de dates à convertir.\n\n  **Retourne** : \n  - `df` (DataFrame) : Le DataFrame modifié avec la colonne `Date` et la colonne initiale supprimée.\n</details>\n\n<details> \n  <summary>`nettoyer_adresse_normalise(adresse)`</summary>\n  Cette fonction nettoie et normalise une adresse en supprimant les numéros au début et en corrigeant les caractères Unicode. Elle utilise des expressions régulières pour enlever les numéros de début d'adresse et applique une normalisation Unicode pour garantir une uniformité des caractères.\n\n  **Paramètre** : \n  - `adresse` (str) : La chaîne de caractères représentant l'adresse à nettoyer et normaliser.\n\n  **Retourne** : \n  - `adresse` (str) : L'adresse nettoyée et normalisée.\n</details>\n\n<details> \n  <summary>`gen_carte_trajet(ligne, G, m, index_colonne_départ, index_colonne_arrive, couleur)`</summary>\n  Cette fonction génère une carte représentant le trajet entre deux points de départ et d'arrivée. Elle utilise le géocodage pour convertir les noms des stations en coordonnées géographiques, puis calcule l'itinéraire le plus court entre les deux stations sur un graphe de rue. Les itinéraires sont ajoutés à la carte, ainsi que des marqueurs pour les stations de départ et d'arrivée.\n\n  **Paramètres** : \n  - `ligne` (list) : Une ligne contenant les noms des stations de départ et d'arrivée.\n  - `G` (Graph) : Le graphe représentant le réseau de rues de la ville.\n  - `m` (Map) : L'objet de la carte sur lequel le trajet sera tracé.\n  - `index_colonne_départ` (int) : L'indice de la colonne contenant le nom de la station de départ.\n  - `index_colonne_arrive` (int) : L'indice de la colonne contenant le nom de la station d'arrivée.\n  - `couleur` (str) : La couleur de la ligne représentant le trajet.\n\n  **Retourne** : \n  - `m` (Map) : La carte avec l'itinéraire ajouté.\n</details>\n\n<details> \n  <summary>`coordonne(station)`</summary>\n  Cette fonction permet de géocoder le nom d'une station pour obtenir ses coordonnées géographiques (latitude et longitude). Elle utilise la bibliothèque `osmnx` pour rechercher l'emplacement correspondant à la station spécifiée dans la ville de Montpellier, France.\n\n  **Paramètre** : \n  - `station` (str) : Le nom de la station à géocoder.\n\n  **Retourne** : \n  - `latitude` (float) : La latitude de la station.\n  - `longitude` (float) : La longitude de la station.\n</details>\n\n# 6. Future Work\n\n## 6.1 Additional Features\n\n- **Pollution and Traffic Correlation**: Investigate correlations between bike traffic patterns and air quality metrics.\n- **Real-Time Traffic Analysis**: Integrate live data feeds for real-time updates, route suggestions, and traffic monitoring.\n- **Alternative Routes**: Offer optimized routes with lower traffic density, based on real-time or historical traffic data.\n\n# 7. Technical Appendix\n\nThis section provides detailed documentation of the project’s functions and code, ensuring ease of understanding for future development or maintenance. Each function is accompanied by a standardized docstring to support collaboration within the development team.\n\n",
    "supporting": [
      "docu_files"
    ],
    "filters": [],
    "includes": {}
  }
}